<!--
An iframe that automatically makes itself as tall as the contained page.

Note: modern iframes should support a "seamless" attribute that should do
exactly what this element does. However, none of the browsers that claim to
support it seem to do anything really useful with it. (E.g., they just hide the
frame border, but don't resize the frame.)

If the framed page contains a basic-framed-content element, this element will
communicate with that inner element. Setting the framedContent property on this
element will pass the content to the basic-framed-content element. If the inner
basic-framed-content's content changes, it will let this element know, and this
element will raise a framedContentChanged event.

TODO: Extend an HTML iframe element directly?
TODO: Give contained pages on the same domain more direct ways to cooperatively
communicate with this element.
-->

<link rel="import" href="../polymer/polymer.html">

<polymer-element name="basic-seamless-iframe" attributes="src">

<template>

  <style>
  :host {
    display: block;
  }

  #iframe {
    border: none;
    display: block;
    height: 100%;
    width: 100%;
  }
  </style>

  <iframe id="iframe" src="{{src}}"></iframe>

</template>

<script>
Polymer( "basic-seamless-iframe", {

  // TODO: This currently inspects the framed page, which is only permissible
  // on pages of the same domain. The basic-framed-content component shares its
  // height; use that instead of inspect the height directly.
  // autoSize: function() {
  //   var page = this.$.iframe.contentDocument.querySelector( "html" );
  //   if ( page ) {
  //     // To get the page height, some StackOverflow solutions suggest using
  //     // scrollHeight, but Firefox always returns a scrollHeight of 0.
  //     // offsetHeight seems to work better.
  //     var frameHeight = Math.ceil( page.offsetHeight ) + "px";
  //     this.style.height = frameHeight;
  //     this.$.iframe.setAttribute( "scrolling", "no" );
  //   }
  // },

  setFramedContent: function( content ) {
    this._pendingContent = content;
    this._updateFramedContent();
  },

  frameReady: false,

  get iframe() {
    return this.$.iframe;
  },

  ready: function() {
    window.addEventListener( "resize", function() {
      if ( this.clientWidth !== this._clientWidth ) {
        this.autoSize();
        this._clientWidth = this.clientWidth;
      }
    }.bind( this ));

    // Raise our own load event when the frame loads.
    this.$.iframe.addEventListener( "load", function() {
      this.dispatchEvent( new CustomEvent( "load" ));
    }.bind( this ));

    window.addEventListener( "message", function( event ) {
      switch ( event.data && event.data.message ) {

        case "framedContentChanged":
          this._framedContentChanged( event.data.content, event.data.height );

        case "framedPolymerReady":
          this.frameReady = true;
          this._updateFramedContent();

      }
    }.bind( this ), false );
  },

  // Track the last known width of this element.
  _clientWidth: null,

  _framedContentChanged: function( framedContent, framedHeight ) {
    // HACK: Even thought the frame says it's done loading, if we inspect the
    // height immediately, it's close but not quite right. Something still
    // hasn't finished rendering (perhaps Polymer's still upgrading elements?).
    // We give the frame another event tick to finish rendering before we do our
    // auto-size.
    // setTimeout( function() {
    //   this.autoSize();
    this.style.height = framedHeight + "px";
    var event = new CustomEvent( "framedContentChanged", {
      detail: framedContent
    });
    this.dispatchEvent( event );
    // }.bind( this ), 1 );
  },

  _pendingContent: null,

  _updateFramedContent: function() {
    if ( this.frameReady && this._pendingContent != null ) {
      this.$.iframe.contentWindow.postMessage({
        message: "setContent",
        content: this._pendingContent
      }, "*" );
      this._pendingContent = null;
    }
  }

});
</script>

</polymer-element>
