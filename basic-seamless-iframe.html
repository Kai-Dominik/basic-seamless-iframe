<!--
An iframe that automatically makes itself as tall as the contained page.

Note: modern iframes should support a "seamless" attribute that should do
exactly what this element does. However, none of the browsers that claim to
support it seem to do anything really useful with it. (E.g., they just hide the
frame border, but don't resize the frame.)

If the framed page contains a basic-framed-content element, this element will
communicate with that inner element. Setting the framedContent property on this
element will pass the content to the basic-framed-content element. If the inner
basic-framed-content's content changes, it will let this element know, and this
element will raise a framedContentChanged event.

TODO: Extend an HTML iframe element directly?
TODO: Give contained pages on the same domain more direct ways to cooperatively
communicate with this element.
-->

<link rel="import" href="../polymer/polymer.html">

<polymer-element name="basic-seamless-iframe">

<template>

  <style>
  :host {
    display: block;
  }

  #iframe {
    border: none;
    display: block;
    height: 100%;
    width: 100%;
  }
  </style>

  <iframe id="iframe" src="{{src}}" scrollbars="no"></iframe>

</template>

<script>
Polymer( "basic-seamless-iframe", {

  autoSizeChanged: function() {
    if ( this.autoSize ) {
      this._postMessageToFrame( "requestHeight" );      
    }
  },

  frameReady: false,

  get iframe() {
    return this.$.iframe;
  },

  publish: {
    autoSize: {
      value: true,
      reflect: true
    },
    src: {
      value: "",
      reflect: true
    }
  },

  ready: function() {
    window.addEventListener( "resize", function() {
      if ( this.autoSize && this.clientWidth !== this._clientWidth ) {
        // Ping framed content for its new -- potentially changed -- height.
        this._postMessageToFrame( "requestHeight" );
        this._clientWidth = this.clientWidth;
      }
    }.bind( this ));

    // Raise our own load event when the frame loads.
    this.$.iframe.addEventListener( "load", function() {
      this.dispatchEvent( new CustomEvent( "load" ));
    }.bind( this ));

    window.addEventListener( "message", function( event ) {
      switch ( event.data && event.data.message ) {

        case "framedContentResponse":
          this._framedContentChanged( event.data.detail );

        case "framedHeightResponse":
          this._framedHeightChanged( event.data.detail );

        case "framedPolymerReady":
          this.frameReady = true;
          this._updateFramedContent();

      }
    }.bind( this ), false );
  },

  setFramedContent: function( content ) {
    this._pendingContent = content;
    this._updateFramedContent();
  },

  // Track the last known width of this element.
  _clientWidth: null,

  _framedContentChanged: function( framedContent ) {
    var event = new CustomEvent( "framedContentChanged", {
      detail: framedContent
    });
    this.dispatchEvent( event );
  },

  _framedHeightChanged: function( framedHeight ) {
    if ( this.autoSize ) {
      this.style.height = framedHeight + "px";
    }
  },

  _pendingContent: null,

  _updateFramedContent: function() {
    if ( this.frameReady && this._pendingContent != null ) {
      this._postMessageToFrame( "setContent", this._pendingContent );
      this._pendingContent = null;
    }
  },

  _postMessageToFrame: function( message, detail ) {
    var payload = {
      message: message
    };
    if ( detail ) {
      payload.detail = detail;
    }
    this.$.iframe.contentWindow.postMessage( payload, "*" );
  }

});
</script>

</polymer-element>
